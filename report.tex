\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{alphabeta}

\usepackage{sectsty}
\sectionfont{\centering}

\title{Εργασία Τεχνητής Νοημοσύνης 2020}
\author{Σπύρος Μαντέλος Α.Μ: 4104\\Χρήστος Γεωργίου Μουσσές Α.Μ: 4206\\Γεώργιος Μήτσης Α.Μ: 4258}
\date{}
\begin{document}

    \maketitle
    
    \section*{Άσκηση 1}
        Στην πρώτη άσκηση υλοποιήθηκαν οι αλγόριθμοι \textbf{UCS} και \textbf{A*} στα πλαίσια της εύρεσης μίας ακολουθίας κινήσεων κάποιων σφαιρών ώστε να έρθουν σε μία αποδεκτή τελική κατάσταση.
   
    \subsection*{Αλγόριθμος}
        Το πρόβλημα απαιτεί οι αρχικές καταστάσεις να περιέχουν ίσο αριθμό n από μαύρες("Μ") και άσπρες("Α") σφαίρες, και μία κενή θέση("-"). Στη συνέχεια, ανταλλάσοντας σε κάθε βήμα μία οποιαδήποτε σφαίρα με την κενή θέση, με τον περιορισμό ότι η απόσταση μεταξύ τους να είναι το πολύ ίση με n και το κόστος γι' αυτή τη μεταφορά να ισούται με n, θέλουμε να φτάσουμε σε μία τελική κατάσταση όπου όλες οι μαύρες σφαίρες βρίσκονται στις αριστερότερες θέσεις, ενώ στην δεξιότερη θέση βρίσκεται υποχρεωτικά μια άσπρη σφαίρα.
        Ο γενικός αλγόριθμος που ακολουθήθηκε είναι ο γενικός αλγόριθμος αναζήτησης που περιγράφεται στις διαφάνειες του μαθήματος, ο ποίος περιλαμβάνει τα ακόλουθα βήματα:
        \begin{enumerate}
          \item Βάλε την αρχική κατάσταση στο μέτωπο της αναζήτησης.
          \item Αν το μέτωπο αναζήτησης είναι άδειο τότε τερμάτισε τον αλγόριθμο.
          \item Πάρε την πρώτη σε σειρά κατάσταση του μετώπου της αναζήτησης.
          \item Αν αυτή η κατάσταση ανήκει στο κλειστό σύνολο τότε αφαίρεσέ τη από το μέτωπο αναζήτησης και επίστρεψε στο βήμα 2. 
          \item Αν η κατάσταση αυτή  είναι τελική τότε τύπωσε τη λύση και τερμάτισε τον αλγόριθμο.
          \item Εφάρμοσε τους τελεστές μετάβασης για να παράγεις τις καταστάσεις-παιδιά.
          \item Βάλε τις νέες καταστάσεις-παιδιά στο μέτωπο της αναζήτησης (σύμφωνα με το κριτήριο όπου χαρακτηρίζει τον αλγόριθμο).
          \item Βάλε την κατάσταση-γονέα στο κλειστό σύνολο. 
          \item Επίστρεψε στο βήμα 2.
        \end{enumerate}
        \newpage
        Για τον αλγόριθμο \textbf{UCS}, στο βήμα 3 επιλέγεται η κατάσταση με το μικρότερο κόστος από την αφετηρία μέχρι την τρέχουσα κατάσταση. Το κόστος υπολογίζεται κατά την επέκταση σε κάθε παιδί και ισούται με το κόστος της γονικής κατάστασης συν το κόστος μετάβασης από τη γονική κατάσταση στο εκάστοτε παιδί. Έτσι ο αλγόριθμος συνεχίζει μέχρι να βρει μία τελική κατάσταση με μία βέλτιστη, ως προς το συνολικό κόστος, ακολουθία κινήσεων.\\\\
        Ο αλγόριθμος \textbf{A*}, λειτουργεί με το ίδιο τρόπο όπως ο \textbf{UCS}, με μόνη διαφορά τον τρόπο υπολογισμού του κόστους. Το κόστος που επιλέγεται για κάθε τρέχουσα κατάσταση, ισούται με το άθροισμα του πραγματικού κόστους από την αρχική κατάσταση μέχρι την τρέχουσα κατάσταση και μία εκτίμηση του κόστους από την τρέχουσα κατάσταση μέχρι την τελική κατάσταση, την οποία επιστρέφει μία ευρετική συνάρτηση. Επίσης αυτός ο αλγόριθμος, δίνει βέλτιστη λύση, με την προϋπόθεση ότι η ευρετική συνάρτηση είναι αποδεκτή και συνεπής.
    
    \subsection*{Ευρετική Συνάρτηση}
        Για να προκύψει βέλτιστη λύση από τον αλγόριθμο \textbf{A*}, πρέπει να χρησιμοποιήσουμε μία αποδεκτή ευρετική συνάρτηση. Για να είναι αποδεκτή, πρέπει η εκτίμηση της απόστασης που επιστρέφει η ευρετική συνάρτηση να είναι μικρότερη η ίση από την πραγματική. \\\\
        Μια στρατηγική κατασκευής αποδεκτών ευρετικών συναρτήσεων είναι, αφαιρώντας περιορισμούς, να κατασκευάσουμε ένα χαλαρωμένο πρόβλημα στο οποίο μπορούμε να βρούμε τη βέλτιστη λύση η οποία θα είναι ένας αποδεκτός ευρετικός μηχανισμός για το αρχικό μας πρόβλημα.\\\\ 
        
        Τελική Ευρετική εδώ...
    \subsection*{Υλοποίηση}
        Η υλοποίηση των αλγορίθμων, έγινε σε γλώσσα \textbf{Java}. Αρχικά ζητείται από το χρήστη να εισάγει την αρχική κατάσταση του προβλήματος. Εδώ του δίνονται δύο δυνατότητες: μπορεί είτε να εισάγει μια αρχική κατάσταση (η οποία ελέγχεται ώστε να είναι συμβατή με τις απαιτήσεις του προβλήματος), είτε να δώσει έναν αριθμό για το πλήθος των μπαλών του κάθε χρώματος (έστω Ν), ώστε να δημιουργηθεί τυχαία μία αρχική κατάσταση μήκους 2n+1. Στην συνέχεια εκτελούνται οι αλγόριθμοι \textbf{UCS} και \textbf{A*} μέχρι την εύρεση μίας αποδεκτής τελικής κατάστασης (σύμφωνης με τους κανόνες του προβλήματος) και τυπώνονται οι ενδιάμεσες καταστάσεις της λύσης που βρέθηκε για τους δύο αλγόριθμους. Τέλος για κάθε αλγόριθμο εκτυπώνεται ο αριθμός των κόμβων που χρειάστηκε να επισκεφθεί καθώς και ο χρόνος εκτέλεσης που απαιτήθηκε.\\\\
        Οι υλοποιήσεις των δύο αλγορίθμων χρησιμοποιούν τη συνάρτηση γενικής αναζήτησης που περιγράφηκε παραπάνω με τις απαραίτητες τροποποιήσεις παραμέτρων για κάθε αλγόριθμο. Η πληροφορία για κάθε κόμβο αποθηκεύεται σε ένα αντικείμενο τύπου \textbf{Node}, το οποίο περιέχει την συμβολοσειρά που παριστάνει την τωρινή κατάσταση, τη γονική κατάσταση, το τρέχον κόστος υπολογισμένο από την αρχική κατάσταση καθώς και την τιμή της ευρετικής συνάρτησης από τον τρέχοντα κόμβο έως την τελική κατάσταση. Στην περίπτωση του αλγόριθμου \textbf{UCS} η τιμή της ευρετικής συνάρτησης παραμένει πάντα στο 0. Η αναζήτηση συνεχίζεται δημιουργώντας τα παιδιά της τρέχουσας κατάστασης υπολογίζοντας το κόστος τους, και στην περίπτωση του \textbf{Α*} υπολογίζεται επιπρόσθετα και η τιμή της ευρετικής συνάρτησης.\\\\
        
        Περιγραφή αλγόριθμου εδώ.\\\\
        Ο αλγόριθμος \textbf{UCS} εξ' ορισμού βρίσκει τη βέλτιστη λύση με το μικρότερο κόστος διαδρομής. Το ίδιο συμβαίνει και για τον αλγόριθμο \textbf{Α*} ο οποίος βρίσκει διαδρομή ίδιου κόστους με τον αλγόριθμο \textbf{UCS} από τη στιγμή που η ευρετική συνάρτηση που χρησιμοποιήθηκε είναι αποδεκτή. Όμως αυτή δεν είναι απαραίτητα η ίδια. Ο αλγόριθμος \textbf{A*} αναπτύσσει σχεδόν πάντα αισθητά λιγότερους κόμβους με αποτέλεσμα να έχει καλύτερους χρόνους εκτέλεσης. ???Όμως σε κάποιες αρχικές καταστάσεις τυχαίνει οι κόμβοι που αναπτύσσονται να πλησιάζουν αρκετά και ο \textbf{A*} μπορεί σε λίγες περιπτώσεις να πάρει περισσότερο χρόνο για τον υπολογισμό του???.\\\\
        
        Δοκιμες: δύσκολη κατάσταση οπου η παλια ευρετικη και ο ucs χρειάζονται πολύ χρόνο και κόμβους να ελέγξουν, μεγάλη συμβολοσειρά, συγκριτικά γραφήματα χρόνου, συγκριτικά γραφήματα ευρετικών.
    
    \newpage
    
    \section*{Άσκηση 2}
        Στη δεύτερη άσκηση υλοποιήθηκε ο αλγόριθμος \textbf{MINIMAX} στα πλαίσια του παιγνίου δύο παικτών SOS.

    \subsection*{Αλγόριθμος}
        Η επιλογή της ευρετικής συνάρτησης αξίας έγινε με βάση τον κανόνα τερματισμού του παιγνίου λαμβάνοντας υπόψη επιπρόσθετα και το βάθος της απόφασης στο δέντρο απόφασης του αλγόριθμου.\\\\
        Πιο συγκεκριμένα ορίστηκαν οι εξής τιμές για την αξία των τελικών καταστάσεων:
        \begin{itemize}
            \item \textit{(10 – \textbf{depth})} αν ο παίκτης υπολογιστής εκτελεί νικητήρια κίνηση σε βάθος απόφασης \textit{\textbf{depth}}.
            \item \textit{(-10 + \textbf{depth})} αν ο παίκτης χρήστης εκτελεί νικητήρια κίνηση σε βάθος απόφασης \textit{\textbf{depth}}.
            \item \textit{0} αν το παίγνιο λήγει σε ισοπαλία (κανένας παίκτης δεν έχει νικήσει και το ταμπλό είναι γεμάτο).
        \end{itemize}
        Κάνοντας αυτή την αξιολόγηση, η ευρετική συνάρτηση αξίας μπορεί να δώσει στις τερματικές καταστάσεις ως τιμές τους ακέραιους στο διάστημα
        [-9, -2] για νικητήρια κίνηση του παίκτη χρήστη, 0 για ισοπαλία και τους ακέραιους στο διάστημα [2, 9] για
        νικητήρια κίνηση του παίκτη υπολογιστή. Εδώ χρησιμοποιήθηκε το γεγονός πως το μέγιστο βάθος του δέντρου
        απόφασης είναι 8 (στην αρχή του παιχνιδιού υπάρχουν 8 διαθέσιμες θέσεις
        για τοποθέτηση είτε S είτε O).\\\\
        Με αυτόν τον τρόπο δίνεται προτεραιότητα στην επιλογή κινήσεων που οδηγούν τον παίκτη υπολογιστή σε νίκες που βρίσκονται σε μικρό βάθος απόφασης, “τιμωρόντας” παράλληλα την επιλογή
        κινήσεων που οδηγούν τον παίκτη υπολογιστή σε ήττες που βρίσκονται σε μικρό βάθος απόφασης.
    
    \subsection*{Υλοποίηση}
        Η υλοποίηση του αλγορίθμου έγινε σε γλώσσα \textbf{Java} και έγινε με τη χρήση αναδρομής όπως αναφέρεται και στην εκφώνηση.\\\\
        Αρχικά, υλοποιήθηκε το
        παιχνίδι μεταξύ δύο χρηστών (με επιλογή ονομάτων), και αφότου βεβαιώθηκε η σωστή λειτουργία του, έπειτα
        υλοποιήθηκε ο αλγόριθμος \textbf{MINIMAX} (επιλογή ονόματος \textbf{minimax}). Για την επιβεβαίωση της σωστής λειτουργίας της υλοποίησης του αλγόριθμου, μεταξύ άλλων συγκρίθηκε ο αριθμός όλων των πιθανών καταστάσεων του παιγνίου στο πλήρες δέντρο καταστάσεων, με τον πραγματικό αριθμό καταστάσεων που επισκέπτεται ο αλγόριθμος κατά την υλοποίησή του στο δέντρο απόφασης. Πιο συγκεκριμένα, υπολογίστηκε ο αριθμός των κόμβων του πλήρους δένδρου καταστάσεων (πλην της ρίζας) σε κάποια διαμόρφωση του ταμπλό, ο οποίος προκύπτει από το άθροισμα: $$\sum_{i=1}^{α}\left[\left(\prod_{n=α+1-i}^{α}n\right)2^{i}\right]$$ όπου το α είναι ο αριθμός των κενών κελιών σε κάποια διαμόρφωση του ταμπλό.\\\\
        Για παράδειγμα, όταν επιλέγεται η πρώτη κίνηση (όπου υπάρχουν 8 κενά κελιά στη συγκεκριμένη διαμόρφωση), το πλήρες δέντρο καταστάσεων περιλαμβάνει, με βάση τον παραπάνω τύπο, 17.017.968 κόμβους (πλην της ρίζας). Η υλοποίηση του αλγόριθμου επισκέπτεται 10.449.792 κόμβους (πλην της ρίζας), κάτι το οποίο είναι αναμενόμενο, αφού υπάρχουν και καταστάσεις σε βάθος μικρότερο από 8, όπου το παίγνιο λήγει με νίκη κάποιου παίκτη ο οποίος έχει σχηματίσει αλυσίδα \textbf{SOS}, χωρίς να έχει συμπληρωθεί πλήρως το ταμπλό του παίγνιου. Έτσι τελικά, ο αριθμός των κόμβων που ελέγχει ο αλγόριθμος στο δέντρο απόφασης, είναι πάντα μικρότερος, ή ίσος από τον αριθμό των κόμβων του πλήρους δέντρου καταστάσεων. \\\\
        Γίνεται άμεσα αντιληπτό πως επειδή ο όγκος των διαμορφώσεων που καλείται να ελέγξει ο παίκτης υπολογιστής είναι πολύ μεγάλος στις αρχικές κινήσεις, ο χρόνος που απαιτείται για την επεξεργασία τους είναι σαφώς μεγαλύτερος από το χρόνο που χρειάζεται  σε μετέπειτα κινήσεις. Δίνεται παρακάτω παράδειγμα ενός ενδεικτικού παιχνιδιού σε γύρους όπου ο υπολογιστής παίζει πρώτος με τον αριθμό διαμορφώσεων που ελέγθηκαν σε κάθε γύρο.
        \begin{enumerate}\addtocounter{enumi}{-1}
        	\centering
            \item Αρχική κατάσταση: 2 1 O
            \item Κίνηση παίκτη \textbf{minimax}: 1 1 O\\ Διαμορφώσεις που ελέγθηκαν: 10.449.792 
            \item Κίνηση παίκτη χρήστη: 2 2 S
            \item Κίνηση παίκτη \textbf{minimax}: 1 2 S\\ Διαμορφώσεις που ελέγθηκαν: 69.228
            \item Κίνηση παίκτη χρήστη: 3 2 S
            \item Κίνηση παίκτη \textbf{minimax}: 1 3 S\\ Διαμορφώσεις που ελέγθηκαν: 620 
            \item Κίνηση παίκτη χρήστη: 3 3 O
            \item Κίνηση παίκτη \textbf{minimax}: 2 3 S\\ Διαμορφώσεις που ελέγθηκαν: 12
            \item Κίνηση παίκτη χρήστη: 3 1 O\\Λήξη του παίγνιου σε ισοπαλία
        \end{enumerate}
        Αν και στην άσκηση ζητείται η υλοποίηση της περίπτωσης που ο παίκτης \textbf{MAX} (παίκτης υπολογιστής) παίζει 
        πρώτος, η υλοποίηση του αλγόριθμου επιτρέπει στον παίκτη υπολογιστή να παίξει επίσης δεύτερος. Επιπρόσθετα,
        υλοποιήθηκε αλγόριθμος που επιτρέπει στον παίκτη υπολογιστή να παίζει, επιλέγοντας τυχαία τις συντεταγμένες και το σύμβολο σε κάθε γύρο (επιλογή ονόματος \textbf{cpu}).
\end{document}
