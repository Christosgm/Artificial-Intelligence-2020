\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{alphabeta}

\usepackage{sectsty}
\sectionfont{\centering}

\title{Εργασία Τεχνητής Νοημοσύνης 2020}
\author{Σπύρος Μαντέλος Α.Μ: 4104\\Χρήστος Γεωργίου Μουσσές Α.Μ: 4206\\Γεώργιος Μήτσης Α.Μ: \textit{unknown}}
\date{}

\begin{document}
\maketitle
\section*{Άσκηση 1}
Στην πρώτη άσκηση υλοποιήθηκαν οι αλγόριθμοι \textbf{UCS} και \textbf{A*} στα πλαίσια της εύρεσης μίας ακολουθίας κινήσεων κάποιων σφαιρών ώστε να έρθουν σε μία αποδεκτή τελική κατάσταση.
\subsection*{Αλγόριθμος}
Το πρόβλημα απαιτεί οι αρχικές καταστάσεις να περιέχουν ίσο αριθμό n από μαύρες("Μ") και άσπρες("Α") σφαίρες, και μία κενή θέση("-"). Στην συνέχεια μετακινώντας μία σφαίρα τη φορά που απέχει το πολύ n θέσεις από την κενή θέση σε αυτή, θέλουμε να φτάσουμε σε μία κατάσταση που όλες οι μαύρες σφαίρες βρίσκονται στις αριστερότερες θέσεις, ενώ στην δεξιότερη βρίσκεται άσπρη σφαίρα.
Ο γενικός αλγόριθμος που ακολουθήθηκε είναι ο γενικός αλγόριθμος αναζήτησης που περιγράφεται στις διαφάνειες του μαθήματος, δηλαδή ο εξής:
\begin{enumerate}
  \item Βάλε την αρχική κατάσταση στο μέτωπο της αναζήτησης.
  \item Αν το μέτωπο αναζήτησης είναι άδειο τότε σταμάτησε.
  \item Πάρε την πρώτη σε σειρά κατάσταση του μετώπου της αναζήτησης.
  \item Αν είναι η κατάσταση αυτή μέρος του κλειστού συνόλου τότε πήγαινε
  στο βήμα 2. 
  \item Αν είναι η κατάσταση αυτή τελική κατάσταση τότε τύπωσε τη λύση και τερμάτισε.
  \item Εφάρμοσε τους τελεστές μετάβασης για να παράγεις τις καταστάσεις-παιδιά.
  \item Βάλε τις νέες καταστάσεις-παιδιά στο μέτωπο της αναζήτησης (σύμφωνα με κάποιο κριτήριο).
  \item Βάλε την κατάσταση-γονέα στο κλειστό σύνολο. 
  \item Πήγαινε στο βήμα 2.
\end{enumerate}
Για τον αλγόριθμο UCS, στο βήμα 3 επιλέγεται η κατάσταση με το μικρότερο κόστος. Το κόστος υπολογίζεται κατά την δημιουργία των παιδιών ως το κόστος την κίνησης που πραγματοποιείται, συν το κόστος της γονικής κατάστασης. Έτσι ο αλγόριθμος συνεχίζει μέχρι να βρει μία τελική κατάσταση με μία βέλτιστη ακολουθία κινήσεων.\par 
Ο αλγόριθμος A*, δουλεύει με το ίδιο τρόπο με τον USC, με μόνη διαφορά το κόστος με το οποίο γίνεται η επιλογή. Αντί να γίνεται επιλογή μόνο με βάση το κόστος αυτής της κατάστασης, χρησιμοποιείται ακόμη μία ευρετική συνάρτηση η οποία προσπαθεί να προσεγγίσει την απόσταση της κάθε κατάστασης από μία αποδεκτή τελική. Και αυτός ο αλγόριθμος δίνει βέλτιστη λύση, με την προϋπόθεση ότι η ευρετική είναι αποδεκτή (μικρότερη η ίση με την πραγματική απόσταση από την τελική κατάσταση).
\subsection*{Ευρετική Συνάρτηση}
Για να έχουμε βέλτιστη λύση από τον αλγόριθμο A*, πρέπει να χρησιμοποιήσουμε μία αποδεκτή ευρετική συνάρτηση. Για να είναι αποδεκτή, πρέπει η απόσταση που θα μας δώσει να είναι μικρότερη η ίση από την πραγματική. \par
Μια στρατηγική κατασκευής αποδεκτών ευρετικών συναρτήσεων είναι αφαιρώντας περιορισμούς να κατασκευάσουμε το χαλαρωμένο πρόβλημα, στο οποίο μπορούμε να βρούμε ακριβώς την απόσταση από την τελική κατάσταση. Η συνάρτηση απόστασης του χαλαρωμένου προβλήματος είναι αποδεκτή ευρετική του αρχικού προβλήματος.\par 
Έτσι στο πρόβλημα αφαιρούμε τον περιορισμό των κινήσεων των μπαλών μόνο στην κενή θέση. Συνεπώς αντί να "ανταλλάσσουμε" θέσεις ανάμεσα σε μία σφαίρα και το κενό, έχουμε την δυνατότητα να αλλάξουμε τις θέσεις και ανάμεσα σε δύο σφαίρες. Ακόμη, δεν απαιτείται η τελευταία θέση να έχει άσπρη σφαίρα. Στο νέο πρόβλημα που δημιουργήσαμε, μπορούμε να βρούμε εύκολα την απόσταση από την τελική κατάσταση. Αρκεί για τις n αριστερότερες θέσεις που δεν περιέχουν ήδη άσπρη σφαίρα, να υπολογίσουμε την απόσταση στην πρώτη μαύρη σφαίρα  που βρίσκεται μετά την n-οστή θέση και με κάποιον τρόπο να κρατάμε πληροφορία ώστε να μην υπολογίσουμε την απόσταση μέχρι την ίδια σφαίρα δύο φορές. Ένας εύκολος τρόπος είναι να διαγράφουμε προσωρινά όσες μαύρες σφαίρες ήδη έχουμε μετρήσει την απόσταση προς αυτές. Στην επόμενη υποενότητα δίνονται λεπτομέρειες και για τον τρόπο που υλοποιήθηκε η ευρετική
\subsection*{Υλοποίηση}
Για την υλοποίηση του αλγορίθμου, γράφτηκε ένα πρόγραμμα σε γλώσσα java με το όνομα Search. Αρχικά ο χρήστης πρέπει να δώσει είσοδο για την αρχική κατάσταση της αναζήτησης. Εδώ του δίνονται δύο δυνατότητες. Μπορεί είτε να δώσει την κατάσταση που επιθυμεί (η οποία ελέγχεται ώστε να είναι σωστή σύμφωνα με τις απαιτήσεις του προβλήματος), είτε να δώσει έναν αριθμό για το πλήθος των μπαλών του κάθε χρώματος (έστω n), ώστε να δημιουργηθεί τυχαία μία αρχική κατάσταση μήκους 2n+1. Στην συνέχεια τρέχουν οι δύο αναζητήσεις για την εύρεση μίας αποδεκτής κατάστασης και τυπώνουν τις ενδιάμεσες καταστάσεις μέχρι να φτάσουν σε αυτή. Τέλος εμφανίζονται και οι χρόνοι που πήρε ο κάθε αλγόριθμος και η διαφορά τους. \par
Οι δύο αναζητήσεις χρησιμοποιούν μία συνάρτηση γενικής αναζήτησης την οποία με κάποιες παραμέτρους τροποποιούν ώστε να γίνονται οι σωστές επιλογές. Η πληροφορία για κάθε κόμβο βρίσκεται σε ένα αντικείμενο τύπου της εσωτερικής κλάσης Node το οποίο περιέχει την συμβολοσειρά που παριστάνει την τωρινή κατάσταση, το κόστος και την τιμή της ευρετικής και την γονική κατάσταση. Στην περίπτωση του UCS η τιμή της ευρετικής παραμένει πάντα στο 0. Η αναζήτηση συνεχίζει και κάθε φορά δημιουργεί τα παιδιά κάθε κατάστασης υπολογίζοντας το κόστος της και αν χρειάζεται την τιμή της ευρετικής.\par
Ή ευρετική που χρησιμοποιήθηκε περιγράφηκε παραπάνω. Για απλότητα στην υλοποίηση έγινε μία μικρή τροποποίηση χωρίς όμως να αλλάζει την τιμή για κάθε κατάσταση ώστε να υπάρχει κίνδυνος να μην είναι αποδεκτή. Διατρέχοντας τις n πρώτες θέσεις την συμβολοσειράς, μετράμε για κάθε θέση που δεν περιέχει μαύρη σφαίρα την απόστασή της μέχρι την κεντρική θέση. Συνεχίζοντας να διατρέχουμε την συμβολοσειρά, για τις υπόλοιπες θέσεις, υπολογίζουμε την απόσταση κάθε σφαίρας μέχρι την κεντρική θέση. Έτσι τελικά έχουμε το κόστος ώστε να μεταφέρουμε κάθε μαύρη σφαίρα στην κεντρική θέση και από εκεί σε μία από τις n δεξιότερες. Αυτή είναι και η ευρετική που αναφέραμε παραπάνω αιτιολογώντας γιατί είναι αποδεκτή. \par
Ο κάθε αλγόριθμος συνεχίζει μέχρι να φτάσουμε σε τελική κατάσταση, όπου στην συνέχεια τυπώνεται το μονοπάτι που ακολούθησε. Δηλαδή τυπώνονται οι καταστάσεις που βρεθήκαμε διαδοχικά μέχρι την τελική. Ακόμη τυπώνονται το συνολικό κόστος να βρεθούμε στην κατάσταση αυτή και οι κόμβοι που αναπτύχθηκαν. Τέλος τυπώνονται οι χρόνοι που χρειάστηκαν οι αλγόριθμοι και η διαφορά τους.\par 
Αφού και οι δύο αλγόριθμοι είναι βέλτιστοι δίνουν πάντα λύση ίδιου κόστους. Όμως αυτή δεν είναι απαραίτητα η ίδια. Ο αλγόριθμος A* αναπτύσσει σχεδόν πάντα σαφώς λιγότερους κόμβους με αποτέλεσμα να έχει καλύτερους χρόνους. Όμως σε κάποιες αρχικές καταστάσεις τυχαίνει οι κόμβοι που αναπτύσσονται να πλησιάζουν αρκετά και ο A* μπορεί σε λίγες περιπτώσεις να πάρει περισσότερο χρόνο για τον υπολογισμό του. Τέλος να αναφερθεί ότι από 7 σφαίρες κάθε χρώματος και πάνω, ο χρόνος εκτέλεσης γίνεται πολύ μεγάλος εκτός αν ξεκινήσουμε από αρκετά ευνοϊκή αρχική κατάσταση.
\newpage
\section*{Άσκηση 2}
Στη δεύτερη άσκηση υλοποιήθηκε ο αλγόριθμος \textbf{MINIMAX} στα πλαίσια του παιγνίου δύο παικτών SOS.
\subsection*{Αλγόριθμος}
Η επιλογή της ευρετικής συνάρτησης αξίας έγινε με βάση τον κανόνα τερματισμού του παιγνίου λαμβάνοντας υπόψη επιπρόσθετα και το βάθος της απόφασης στο δέντρο απόφασης του αλγόριθμου.\\\\
Πιο συγκεκριμένα ορίστηκαν οι εξής τιμές για την αξία των τελικών καταστάσεων:
\begin{itemize}
    \item \textit{(10 – \textbf{depth})} αν ο παίκτης υπολογιστής εκτελεί νικητήρια κίνηση σε βάθος απόφασης \textit{\textbf{depth}}.
    \item \textit{(-10 + \textbf{depth})} αν ο παίκτης χρήστης εκτελεί νικητήρια κίνηση σε βάθος απόφασης \textit{\textbf{depth}}.
    \item \textit{0} αν το παίγνιο λήγει σε ισοπαλία (κανένας παίκτης δεν έχει νικήσει και το ταμπλό είναι γεμάτο).
\end{itemize}
Κάνοντας αυτή την αξιολόγηση, η ευρετική συνάρτηση αξίας μπορεί να δώσει στις τερματικές καταστάσεις ως τιμές τους ακέραιους στο διάστημα
[-9, -2] για νικητήρια κίνηση του παίκτη χρήστη, 0 για ισοπαλία και τους ακέραιους στο διάστημα [2, 9] για
νικητήρια κίνηση του παίκτη υπολογιστή. Εδώ χρησιμοποιήθηκε το γεγονός πως το μέγιστο βάθος του δέντρου
απόφασης είναι 8 (στην αρχή του παιχνιδιού υπάρχουν 8 διαθέσιμες θέσεις
για τοποθέτηση είτε S είτε O).\\\\
Με αυτόν τον τρόπο δίνεται προτεραιότητα στην επιλογή κινήσεων που οδηγούν τον παίκτη υπολογιστή σε νίκες που βρίσκονται σε μικρό βάθος απόφασης, “τιμωρόντας” παράλληλα την επιλογή
κινήσεων που οδηγούν τον παίκτη υπολογιστή σε ήττες που βρίσκονται σε μικρό βάθος απόφασης.

\subsection*{Υλοποίηση}
Η υλοποίηση του αλγορίθμου έγινε σε γλώσσα \textbf{Java} και έγινε με τη χρήση αναδρομής όπως αναφέρεται και στην εκφώνηση.\\\\
Αρχικά, υλοποιήθηκε το
παιχνίδι μεταξύ δύο χρηστών (με επιλογή ονομάτων), και αφότου βεβαιώθηκε η σωστή λειτουργία του, έπειτα
υλοποιήθηκε ο αλγόριθμος \textbf{MINIMAX} (επιλογή ονόματος \textbf{minimax}). Για την επιβεβαίωση της σωστής λειτουργίας της υλοποίησης του αλγόριθμου, μεταξύ άλλων συγκρίθηκε ο αριθμός όλων των πιθανών καταστάσεων του παιγνίου στο πλήρες δέντρο καταστάσεων, με τον πραγματικό αριθμό καταστάσεων που επισκέπτεται ο αλγόριθμος κατά την υλοποίησή του στο δέντρο απόφασης. Πιο συγκεκριμένα, υπολογίστηκε ο αριθμός των κόμβων του πλήρους δένδρου καταστάσεων (πλην της ρίζας) σε κάποια διαμόρφωση του ταμπλό, ο οποίος προκύπτει από το άθροισμα: $$\sum_{i=1}^{α}\left[\left(\prod_{n=α+1-i}^{α}n\right)2^{i}\right]$$ όπου το α είναι ο αριθμός των κενών κελιών σε κάποια διαμόρφωση του ταμπλό.\\\\
Για παράδειγμα, όταν επιλέγεται η πρώτη κίνηση (όπου υπάρχουν 8 κενά κελιά στη συγκεκριμένη διαμόρφωση), το πλήρες δέντρο καταστάσεων περιλαμβάνει, με βάση τον παραπάνω τύπο, 17.017.968 κόμβους (πλην της ρίζας). Η υλοποίηση του αλγόριθμου επισκέπτεται 10.449.792 κόμβους (πλην της ρίζας), κάτι το οποίο είναι αναμενόμενο, αφού υπάρχουν και καταστάσεις σε βάθος μικρότερο από 8, όπου το παίγνιο λήγει με νίκη κάποιου παίκτη ο οποίος έχει σχηματίσει αλυσίδα \textbf{SOS}, χωρίς να έχει συμπληρωθεί πλήρως το ταμπλό του παίγνιου. Έτσι τελικά, ο αριθμός των κόμβων που ελέγχει ο αλγόριθμος στο δέντρο απόφασης, είναι πάντα μικρότερος, ή ίσος από τον αριθμό των κόμβων του πλήρους δέντρου καταστάσεων. \\\\
Γίνεται άμεσα αντιληπτό πως επειδή ο όγκος των διαμορφώσεων που καλείται να ελέγξει ο παίκτης υπολογιστής είναι πολύ μεγάλος στις αρχικές κινήσεις, ο χρόνος που απαιτείται για την επεξεργασία τους είναι σαφώς μεγαλύτερος από το χρόνο που χρειάζεται  σε μετέπειτα κινήσεις. Δίνεται παρακάτω παράδειγμα ενός ενδεικτικού παιχνιδιού σε γύρους όπου ο υπολογιστής παίζει πρώτος με τον αριθμό διαμορφώσεων που ελέγθηκαν σε κάθε γύρο.
\begin{enumerate}\addtocounter{enumi}{-1}
	\centering
    \item Αρχική κατάσταση: 2 1 O
    \item Κίνηση παίκτη \textbf{minimax}: 1 1 O\\ Διαμορφώσεις που ελέγθηκαν: 10.449.792 
    \item Κίνηση παίκτη χρήστη: 2 2 S
    \item Κίνηση παίκτη \textbf{minimax}: 1 2 S\\ Διαμορφώσεις που ελέγθηκαν: 69.228
    \item Κίνηση παίκτη χρήστη: 3 2 S
    \item Κίνηση παίκτη \textbf{minimax}: 1 3 S\\ Διαμορφώσεις που ελέγθηκαν: 620 
    \item Κίνηση παίκτη χρήστη: 3 3 O
    \item Κίνηση παίκτη \textbf{minimax}: 2 3 S\\ Διαμορφώσεις που ελέγθηκαν: 12
    \item Κίνηση παίκτη χρήστη: 3 1 O\\Λήξη του παίγνιου σε ισοπαλία
\end{enumerate}
Αν και στην άσκηση ζητείται η υλοποίηση της περίπτωσης που ο παίκτης \textbf{MAX} (παίκτης υπολογιστής) παίζει 
πρώτος, η υλοποίηση του αλγόριθμου επιτρέπει στον παίκτη υπολογιστή να παίξει επίσης δεύτερος. Επιπρόσθετα,
υλοποιήθηκε αλγόριθμος που επιτρέπει στον παίκτη υπολογιστή να παίζει, επιλέγοντας τυχαία τις συντεταγμένες και το σύμβολο σε κάθε γύρο (επιλογή ονόματος \textbf{cpu}).
\end{document}
